#lang racket/base

;;;
;;; CONTROL
;;;

; The interface between the web-server in "server.rkt" and the control
; is the function `dispatch`. Each time the web-server receives an request
; it is passes on to `dispatch`.

(provide dispatch)

;; Imports

(require (for-syntax racket/base)
         racket/match
         racket/promise
         racket/runtime-path
         web-server/dispatch/extend
         web-server/servlet-env
         web-server/servlet
         web-server/http/redirect
         web-server/http/cookie
         web-server/http/id-cookie ; authenticated cookies
         ; "config.rkt"
         "def.rkt" "exn.rkt" "parameters.rkt" "structs.rkt"
         "validation.rkt"
         "model.rkt" "view.rkt")

;;;
;;; Utils
;;;

(define (bytes->number b)
  (string->number (bytes->string/utf-8 b)))

;;;
;;; Bindings
;;;

; get-binding
;   Extract a binding from the request if present and then
;   apply convert to the extracted value.
;   Typical use:  (get-binding #"username" bytes->string-utf/8)
(define (get-binding binding-name [convert values] #:request [req (current-request)])
  (match (bindings-assq binding-name (request-bindings/raw req))
    [(? binding:form? b) (convert (binding:form-value b))]
    [_ #f]))

;;;
;;; Cookies
;;;

; We are going to store session information (such as login status)
; on the client in cookies. To make these tamper proof, we need
; a way to verify, that they haven't been changed by the user.

; In order to store `authored-seconds&data` we send
; `digest&authored-seconds&data` where digest is a
; cryptographics hash of authored-seconds&data and, very important,
; a secret salt only known to the server(s).
; If using multiple servers, they need to share the secret salt.

; In short: we are not encrypting the data, we are merely
; associating it with a digest, so it can't be altered.

(define-runtime-path cookie-salt.bin "cookie-salt.bin")
(def cookie-salt (make-secret-salt/file cookie-salt.bin))

(define (make-logged-in-cookie)
  (make-id-cookie "login-status" "in"
                  #:key        cookie-salt
                  ; only for http/https (not client side javascript)
                  #:http-only? #t           
                  ; #:expires ...
                  ; #:max-age ...                            
                  ; #:secure? #t  ; instructs client only to send cookie via https
                  ))

(define (make-logged-out-cookie)
  (make-id-cookie "login-status" "out"
                  #:key cookie-salt
                  #:http-only? #t))


(define (make-username-cookie username)
  (make-id-cookie "username" username
                  #:key        cookie-salt
                  #:http-only? #t))

(define (get-cookie-value req name)
  (request-id-cookie req #:name name #:key  cookie-salt
                     ; #:timeout ...
                     ; #:shelf-life ...
                     ))

(define (get-login-status req)
  (match (get-cookie-value req "login-status")
    ["in" #t]
    [_    #f]))
                     
;;;
;;; DISPATCH
;;;

; from web-server/dispatch/url-patterns
(define-syntax define-bidi-match-expander/coercions
  (syntax-rules ()
    [(_ id in-test? in out-test? out)
     (begin (define-coercion-match-expander in/m in-test? in)
            (define-coercion-match-expander out/m out-test? out)
            (define-bidi-match-expander id in/m out/m))]))

;; (define string->integer? (make-coerce-safe? string->integer))
;; (define-bidi-match-expander/coercions integer-arg
;;   string->integer? string->integer
;;   integer? number->string)

(define (vote-direction? x) (or (equal? x "up") (equal? x "down")))
(define-bidi-match-expander/coercions vote-direction-arg
  vote-direction? values vote-direction?  values)

(define (t who f) (λ xs (displayln who) (apply f xs)))

(define (dispatch req)
  (current-request req)
  (def login-status (get-login-status req))
  (def username     (and login-status (get-cookie-value req "username")))
  (def user         (and username (get-user #:username username)))
  
  (parameterize ([current-login-status (and user login-status)]
                 [current-user         (and login-status user)])
    (dispatch-on-url req)))

(defv (dispatch-on-url generate-url)
  ; pages:   show a given html page (generated by the view)
  ; actions: performs action, then redirects to a page
  (dispatch-rules
   ; pages
   [("")                                          do-home]                 
   [("home")                                      do-home]                 
   [("about")                                     do-about]                
   [("login")                                     do-login/create-account] 
   [("submit")                                    do-submit]               ; new entry page
   
   ; actions 
   [("vote" (vote-direction-arg) (integer-arg)) #:method "post"  do-vote]

   ; form submissions
   [("logout-submitted")         #:method "post"  do-logout-submitted] ; logout, then show front page
   [("entry-submitted")          #:method "post"  do-entry-submitted]
   [("login-submitted")          #:method "post"  do-login-submitted]
   [("create-account-submitted") #:method "post"  do-create-account-submitted]
   [else
    (λ (req)
      (displayln "!!!")
      (displayln (url->string (request-uri req)))
      (displayln (request-method req))
      (do-home req))]))

;;;
;;; PAGES
;;;

(define (do-about req)
  (def result (html-about-page))
  (response/output (λ (out) (display result out))))

(define (do-home req . xs)
  (def result (html-home-page 0 1 (page 0)))
  (response/output (λ (out) (display result out))))

(define (do-login/create-account req)
  (def result (html-login-page))
  (response/output (λ (out) (display result out))))


(define (do-logout-submitted req)
  (displayln "logging out")
  (def result (html-login-page))
  (redirect-to "/" temporarily
               #:headers (map cookie->header
                              (list (make-logged-out-cookie)))))

(define (do-login-submitted req)
  (displayln 'do-login-submitted)
  (def u  (get-binding #"username" bytes->string/utf-8))
  (def p  (get-binding #"password"))
  (displayln (list 'u u 'p p))
  (cond
    [(and u p) (match (authenticate-user u p)
                 ; On a successful login we generate a logged-in cookie,
                 ; and redirect to the frontpage.
                 ; The redirection prevents the form data being submitted
                 ; twice due to reloads in the browser.
                 [#t
                  (displayln (list 'do-submit-login "login ok"))
                  (redirect-to
                   "/" temporarily
                   #:headers (map cookie->header
                                  (list (make-username-cookie u)
                                        (make-logged-in-cookie))))]
                 ; If the login failed, the user must try again.
                 [(authentication-error msg)                  
                  (displayln (list 'do-submit-login msg))
                  (redirect-to "/login" temporarily)])]
    [else      (displayln (list 'do-submit-login 'u u 'p p))
               (redirect-to "/login" temporarily)]))

(define (do-create-account-submitted req)
  (def u (bytes->string/utf-8 (get-binding #"username")))
  (def p (get-binding #"password"))
  (def e (bytes->string/utf-8 (get-binding #"email")))
  (with-handlers ([exn:fail:user:bad?
                   (λ (e)
                     (def msg (exn-message e))
                     (displayln msg) ; todo: show user
                     (redirect-to "/login" temporarily))])
    (create-user u p e)
    (redirect-to "/" temporarily
                 #:headers (map cookie->header
                                (list (make-username-cookie u)
                                      (make-logged-in-cookie))))))
    


(define (do-vote req direction id) ; an arrow was clicked
  (displayln (list 'do-vote direction id))
  (match direction
    ["up"   (when id (increase-score id))]
    ["down" (when id (decrease-score id))]    
    [else    'do-nothing])
  ; to make sure a reload doesn't resubmit, we redirect to the front page
  (redirect-to "/home" temporarily))


(define (do-submit req)
  (def result (html-submit-page))
  (response/output (λ (out) (display result out))))

;;;
;;; do-submit
;;;

(define (do-entry-submitted req)
  ; We get here when the form on the "Submit new entry" page is submitted.
  (def url   (get-binding #"url"   bytes->string/utf-8))
  (def title (get-binding #"title" bytes->string/utf-8))

  ; If the submitted url and title are valid, we will insert an
  ; entry in the databas and redirect to the database.
  ; If the data is invalid, we need to show the submit page again,
  ; this time with validation results.
  
  (define vu (validate-url   url))   ; see "validation.rkt" for definition
  (define vt (validate-title title))

  (cond
    [(all-valid? vu vt)  (insert-entry (make-entry #:title title #:url url #:score 10))
                         ; to make sure a reload doesn't resubmit, we redirect to the front page
                         (redirect-to "/" temporarily)]
    [else
     (def result (html-submit-page #:validation (list vu vt)))
     (response/output
      #:headers (list (header #"Location" #"foo"))
      (λ (out) (display result out)))]))



#;(dispatch-on-url
   (make-request #"GET" (string->url "http://foo.dk/vote/up3/5")
                 '()
                 (delay '())
                 #f
                 "1.2.3.4"
                 80
                 "4.3.2.1"))
